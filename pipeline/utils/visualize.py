#!/usr/bin/env python
"""
A module to facilitate the visualization of data generated by the pipeline.
"""
from collections import Iterable
import logging
from itertools import chain

from astropy.io import fits

from astropy.time import Time
from astropy.stats import sigma_clipped_stats, LombScargle
import astropy.units as u
from astropy.visualization import ImageNormalize, SqrtStretch, LinearStretch, \
    ZScaleInterval, LogStretch, ManualInterval
# import costools
import cartopy.crs as ccrs
from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER

import dask.array as da
import matplotlib as mpl
#mpl.use('qt5agg')
# from matplotlib import rc
# rc('text', usetex=True)
import matplotlib.pyplot as plt
import matplotlib.colors as colors

plt.style.use('ggplot')
from mpl_toolkits.basemap import Basemap
import matplotlib.colors as colors
from matplotlib.dates import DateFormatter
from matplotlib.legend import Legend
from matplotlib import ticker
import matplotlib as mpl
from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
                               AutoMinorLocator)
import numpy as np
import pandas as pd
import pmagpy.ipmag as ipmag


from scipy.stats import gaussian_kde
import sunpy
import sunpy.timeseries
import sunpy.data.sample

logging.basicConfig(format='%(levelname)-4s '
                           '[%(module)s.%(funcName)s:%(lineno)d]'
                           ' %(message)s',
                    )

LOG = logging.getLogger('visualize')
LOG.setLevel(logging.INFO)


class Visualizer(object):
    """
    A class for visualizing data generated by the pipeline
    """
    def __init__(self):
        pass
        self.image_norms = {
            'log': LogStretch(),
            'linear': LinearStretch(),
            'sqrt' : SqrtStretch(),
        }
        self.map = None

    def mk_fig(self, nrows=1, ncols=1, figsize=(6,6),
               sharex=False,
               sharey=False,
               showgrid=True):
        """ Convenience method for creating a matplotlib figure

        Parameters
        ----------
        nrows : int
            Number of row-subplots to make

        ncols : int
            Number of column-subplots to make

        figsize : tupple of ints
            Size of the figure

        Returns
        -------
        fig : :py:class:`matplotlib.Figure`

        axes : tuple of :py:class:`matplotlib.axes.Axes`
        """
        fig, axes = plt.subplots(nrows=nrows,
                                 ncols=ncols,
                                 figsize=figsize,
                                 sharex=sharex,
                                 sharey=sharey,
                                 gridspec_kw={'wspace': 0.,
                                              'hspace': 0.1})

        if isinstance(axes, Iterable) and not showgrid:
            axes = axes.flatten()
            for ax in axes:
                ax.grid(False)
        elif not showgrid:
            axes.grid(False)
        return fig, axes


    def _perform_SAA_cut(self, df, key):
        saa = [list(t) for t in zip(*costools.saamodel.saaModel(5))]
        saa[0].append(saa[0][0])
        saa[1].append(saa[1][0])
        saa = np.asarray(saa)
        saa_eastern = (39.0, -30.0) # lon/lat
        saa_western = (267.0, -20.0)
        saa_northern = (312.0, 1.0)

        mask = (df['longitude_{}'.format(key)] > saa_eastern[0]) &\
               (df['longitude_{}'.format(key)] < saa_western[0]) &\
               (df['latitude_{}'.format(key)] > saa_northern[1])
        cut = df[mask]

        return cut


    def plot_hist(self, data, bins, label, ax=None, lw=1.75,ls='-',
                  logy=True, logx=False, c='k', range=None, normalize=True):
        """Generate a histogram for a given dataset

        Parameters
        ----------
        data : :py:class:`dask.array`
            THe dask array to use to generate a histogram
        bins: int
            The number of bins to use

        ax : :py:class:`matplotlib.axes.Axes`
            If passed, the histogram will be added to the plot contained by
            this `Axes` instance. Otherwise, one will be created.

        logy : bool
            If True, the y-axis will be plotted on log-scale

        logx : bool
            If True, the logarithm of the `data` input will be taken prior to
            creating the histogram

        Returns
        -------
        fig : :py:class:`matplotlib.figure.Figure`

        ax : :py:class:`matplotlib.axes.Axes`

        hist :
        """
       # if logx:
       #     data = da.log10(data)
        
        if range is not None:
            h, edges = da.histogram(data, bins=bins,
                                    range=range, density=normalize)
        else:
            h, edges = da.histogram(data, bins=bins)
        hist = h.compute()
        
        #if normalize:
        #    hist = hist/hist.max()

        # Create an axis if it doesnt exists
        lw = 1.75
        if ax is None:
            fig, ax = self.mk_fig(nrows=1, ncols=1)
        else:
            fig = ax.get_figure()

        if logx and logy:
            ax.loglog(edges[:-1], hist, basex=10, basey=10,
                        drawstyle='steps-mid',color=c, lw=lw, label=label, ls=ls)
        elif logy:
            # self.ax.step(edges[:-1], h.compute(), color='r')
            ax.semilogy(edges[:-1], hist,
                             label=label,ls=ls,
                             drawstyle='steps-mid', color=c, lw=lw)
        else:
            ax.step(edges[:-1], hist,
                         label=label,ls=ls,
                         where='mid', color=c, lw=lw)
        ax.tick_params(axis='both', which='major',
                       labelsize=10, width=2)
        # ax.legend(loc='best')

        return fig, ax, hist, edges,

    def kde2D_plot(self, parameter1, parameter2, normtype='log',
                   interval=None, xlim=None, ylim=None, gridsize=100):
        """Generate a 2D KDE for the given parameters.

        Parameters
        ----------
        parameter1 : `numpy.array`
            X-axis variable

        parameter2 : `numpy.array`
            Y-axis variable

        normtype : {'log', 'linear', 'sqrt'}
            Normalization type to apply to the data

        interval : tuple
            Limits of the interval to use when computing the image scaling

        xlim : tuple
            X-limits to use for the plot and the KDE grid

        ylim : tuple
            Y-limits to use for the plot and the KDE grid

        gridsize : int
            Step-size for the grid

        Returns
        -------
        fig : :py:class:`matplotlib.figure.Figure`

        ax : :py:class:`matplotlib.axes.Axes`

        surface : numpy.array
            The KDE surface plot
        """

        data = np.vstack([parameter1, parameter2])

        if xlim is None:
            xlim = (np.min(parameter1), np.max(parameter1))

        if ylim is None:
            ylim = (np.min(parameter2), np.max(parameter2))

        # Generate a grid to compute the KDE over
        xgrid = np.linspace(xlim[0], xlim[1], gridsize)
        ygrid = np.linspace(ylim[0], ylim[1], gridsize)


        kde = gaussian_kde(data)
        Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)
        surface = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))

        if isinstance(interval, tuple):
            Interval = ManualInterval(vmin=interval[0], vmax=interval[1])
        else:
            Interval = ZScaleInterval()

        norm = ImageNormalize(surface,
                              stretch=self.image_norms[normtype],
                              interval=Interval)

        fig, ax = self.mk_fig(nrows=1, ncols=1)
        ax.imshow(surface.reshape(Xgrid.shape),
                  norm=norm,
                  cmap='gray',
                  origin='lower',
                  aspect='auto',
                  extent=[xgrid.min(), xgrid.max(), ygrid.min(),ygrid.max()])

        return fig, ax, surface

    def plot_periodogram(self, df, legend_label, exptime_cut=100, ax=None,
                         window='20D', min_periods=10):
        """ Generate a periodogram of the incident CR rate

        Parameters
        ----------
        df : :py:class:`pandas.DataFrame`
            Dataframe containing all of the statistics for the incident CR rate

        legend_label : str
            Label name for the data to display in the plot's legend

        ax : :py:class:`matplotlib.axes.Axes`
            If passed, the histogram will be added to the plot contained by
            this `Axes` instance. Otherwise, one will be created.

         window : str
            String alias for the time period representing the size of the
            moving window. Some common ones are listed below:

            - 'W', one week window
            - '15D', 15 day window
            - 'M', one month window

            A complete list may be found `here <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`_

        min_periods : int
            Minimum number of datapoints that must be in a given window

        Returns
        -------
        frequency : :py:class:`numpy.array` or :py:class:`astropy.Quantity`
            An array of all the frequencies consider in the periodogram

        power : :py:class: `numpy.array`
            An array of the spectral power density associated with frequency

        ax : `matplotlib.axes.Axes`
            The `Axes` for the corresponding plot

        """
        flags = df.integration_time.gt(100)
        df1 = df[flags][['incident_cr_rate','mjd']]
        df1 = df1.rolling(window=window, min_periods=min_periods).mean()
        df1.dropna(inplace=True)
        days = df1['mjd'].values * u.day
        smoothed_rate = df1['incident_cr_rate'].values
        frequency, power = LombScargle(days, smoothed_rate).autopower()

        if ax is None:
            fig, ax = self.mk_fig()
        else:
            ax = ax
        ax.plot(frequency, power, label=legend_label)

        return frequency, power, ax


    def plot_cr_rate_vs_time(self, df, legend_label, ax= None, i=0,min_exptime=200,yoffset=0,
                             smooth_type='rolling',ms=2, window='20D', normalize=True,min_periods=20):
        """Plot the observed cosmic ray rate as a function of time.

        Parameters
        ----------
        df : `pandas.DataFrame`
            DataFrame containing the incident cosmic ray rate information

        legend_label : str
            Label to use for the dataset in the plot legend

        ax : `matplotlib.axes.Axes`
            An instance of a plot to add the current dataset too

        i : int
            Integer used to determine the color of the points used in the
            scatter plot

        smooth_type : {'rolling', 'resample'}
            Type of smoothing to apply to the cosmic ray rate dataset.

            - :py:meth:`pandas.DataFrame.rolling()`
            - :py:meth:`pandas.DataFrame.resample()`

        window : str
            String alias for the time period representing the size of the
            moving window. Some common ones are listed below:

            - 'W', one week window
            - '15D', 15 day window
            - 'M', one month window

            A complete list may be found `here <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`_

        min_periods : int
            Minimum number of datapoints that must be in a given window

        Returns
        -------
        fig : `matplotlib.figure.Figure`

        ax : `matplotlib.axes.Axes`
        """
        # Get the long exposures with reliable statistics
        flags = df.integration_time.gt(min_exptime)
        LOG.info('Total number of observations with exptime > {}: {}'.format(min_exptime,
                                                                             flags.sum()))
        exptime_cut = df[flags]
        #df = self._perform_SAA_cut(df, key='start')
        mean, med, std = sigma_clipped_stats(exptime_cut['incident_cr_rate'], sigma=5)
        mean, median, std = sigma_clipped_stats(exptime_cut['incident_cr_rate'],
                                                sigma_lower=5,
                                                sigma_upper=5)
        LOG.info('{} mean: {} median: {} std: {}'.format(legend_label, mean, median, std))

        sigma_mask = (exptime_cut['incident_cr_rate'] > mean - 3*std) & (exptime_cut['incident_cr_rate'] < mean + 5*std)
        sigma_cut = exptime_cut[sigma_mask]

        df1 = exptime_cut.loc[:, ['incident_cr_rate','mjd']]

        # Smooth the cosmic ray rate
        if smooth_type == 'rolling':
            LOG.info('Smoothing the data using a '
                     'rolling mean over a {} window'.format(window))
            df1 = df1.rolling(window=window, min_periods=min_periods).median()
        elif smooth_type == 'resample':
            LOG.info('Resampling the data using a rolling mean over'
                     'a {} window'.format(window))
            df1 = df1.resample(rule=window).median()
        
        if normalize:
             LOG.info('Normalizing the date by the median value')
             df1.loc[:,'incident_cr_rate'] = df1['incident_cr_rate']/df['incident_cr_rate'].median()

        avg_no_nan = df1.dropna()

        if ax is None:
            fig, ax = self.mk_fig(nrows=1, ncols=1, figsize=(7,4))
        else:
            fig = ax.get_figure()


        # Color cycle to use for repeated use of ax argument
        CB_color_cycle = ['#377eb8', '#ff7f00', '#4daf4a',
                          '#f781bf', '#a65628', '#984ea3',
                          '#999999', '#e41a1c', '#dede00']

        # Make the scatter plot
        ax.scatter([Time(val, format='mjd').to_datetime()
                         for val in avg_no_nan[avg_no_nan.incident_cr_rate.gt(0)]['mjd']],
                        avg_no_nan[avg_no_nan.incident_cr_rate.gt(0)]['incident_cr_rate']+yoffset,
                        label=legend_label,
                        marker='o',
                        s=ms,
                        color=CB_color_cycle[i])
        
        ax.tick_params(labelbottom=False)
        # ax.set_xlabel('Date')
        ax.set_ylabel('Cosmic Ray Rate [$CR/s/cm^2$]', fontsize=14)
        # ax.set_title('Smoothed Cosmic Ray Rate')

        return fig, ax


    def _draw_map(self, map=None, scale=0.9):

        if map is None:
            pass
        else:
            self.map=map
        # Set the background map up
        #self.map.drawcoastlines()
        #self.map.fillcontinents()
        self.map.shadedrelief(scale=scale)

        # Draw the meridians
        # lats and longs are returned as a dictionary
        lats = self.map.drawparallels(np.linspace(-90, 90, 13),
                                      labels=[True, False, False, False],
                                      fontsize=10)

        lons = self.map.drawmeridians(np.linspace(-180, 180, 13),
                                      labels=[False, False, False, True],
                                      fontsize=10)

        # keys contain the plt.Line2D instances
        lat_lines = chain(*(tup[1][0] for tup in lats.items()))
        lon_lines = chain(*(tup[1][0] for tup in lons.items()))
        all_lines = chain(lat_lines, lon_lines)
        # cycle through these lines and set the desired style
        for line in all_lines:
             line.set(linestyle='-', alpha=0.3, color='w')


    def plot_hst_loc(self, i = 5, df = None, title='',thresh=5,
                     fout='',min_exptime=800, key='start', save=False,
                     orbital_path1=None, orbital_path2=None):
        
        self.fig = plt.figure(figsize=(8, 6))
        # Get the model for the SAA
        self.map = Basemap(projection='cyl')
        self._draw_map()
        df = df[df.integration_time.gt(min_exptime)]
        df.sort_values(by='incident_cr_rate', inplace=True)
        cbar_bounds = [0,20,40,60,80,100,120,140,160]
        sci_cmap = plt.cm.gray
        custom_norm = colors.BoundaryNorm(boundaries=cbar_bounds,
                                          ncolors=sci_cmap.N)
        # Generate an SAA contour
        saa = [list(t) for t in zip(*costools.saamodel.saaModel(i))]
        # Ensure the polygon representing the SAA is a closed curve by adding
        # the starting points to the end of the list of lat/lon coords
        saa[0].append(saa[0][0])
        saa[1].append(saa[1][0])
        self.map.plot(saa[1], saa[0],
               c='k',
               latlon=True,
               label='SAA contour {}'.format(i))
        # df = self.perform_SAA_cut(df=df, key=key)
        if df is None:
            lat, lon, rate = self.data_df['latitude_{}'.format(key)], \
                             self.data_df['longitude_{}'.format(key)], \
                             self.data_df['incident_cr_rate']
        else:
            #df = df[df['integration_time'] > 800]
            lat, lon, rate = df['latitude_{}'.format(key)], \
                             df['longitude_{}'.format(key)], \
                             df['incident_cr_rate']
            LOG.info('{} {} {}'.format(len(lat), len(lon), len(rate)))

            # lat1, lon1, rate1 = lat[rate >0], lon[rate >0], rate[rate>0]
            # LOG.info('{} {} {}'.format(len(lat), len(lon), len(rate)))
        # median = np.median(rate)
        # std = np.std(rate)
        mean, median, std = sigma_clipped_stats(rate, sigma_lower=3,
                                                sigma_upper=3)
        LOG.info('{} +\- {}'.format(median, std))
        norm = ImageNormalize(rate,
                              stretch=LinearStretch(),
                              vmin=mean - thresh*std, vmax=mean + thresh*std)
        cbar_below_mean = [mean - (i+1)*std for i in range(thresh)]
        cbar_above_mean = [mean + (i+1)*std for i in range(thresh)]

        cbar_bounds = cbar_below_mean + [mean] + cbar_above_mean
        print(cbar_bounds)
        cbar_bounds.sort()
        sci_cmap = plt.cm.viridis
        custom_norm = colors.BoundaryNorm(boundaries=cbar_bounds,
                                          ncolors=sci_cmap.N)

        scat = self.map.scatter(lon.values, lat.values,
                         marker='o',
                         s=5,
                         latlon=True,
                         c=rate, alpha=0.15,
                         norm = custom_norm,
                         cmap='viridis')
        #im = self.map.contourf(lon_grid, lat_grid, rate, norm=norm, cmap='viridis')
        ax = plt.gca()
        ax.set_title(title)

        # Plot the path of HST
        #self.map.plot(
        #    orbital_path1.metadata['longitude'],
        #    orbital_path1.metadata['latitude'],lw=1.25,
        #    label=f'Int. Time: {1000:.1f}s', color='k', ls='-'
        #)
        if orbital_path2 is not None:
            self.map.scatter(
                orbital_path2.metadata['longitude'][::4][1:],
                orbital_path2.metadata['latitude'][::4][1:],c='k',s=20,label='285 seccond interval'
            )
        if orbital_path1 is not None:
            self.map.plot(
                orbital_path2.metadata['longitude'],
                orbital_path2.metadata['latitude'],
                label=f'Orbital Path Over {2000:.0f} seconds',color='k', ls='--', lw=1.25
            )

        ax1_legend = ax.legend(loc='upper right',
                                ncol=1,
                                labelspacing=0.2,
                                columnspacing=0.5,
                                edgecolor='k')
        # for i in range(len(ax1_legend.legendHandles)):
        #     ax1_legend.legendHandles[i]._sizes = [30]
        #cbar_tick_labels = [f'<x>-{thresh}$\sigma$', '<x>', f'<x>+{thresh}$\sigma$']
        #cbar_ticks = [mean - thresh*std,mean, mean + thresh*std]
        cbar_ticks = cbar_bounds
        cax = self.fig.add_axes([0.1, 0.1, 0.8, 0.05])
        cbar = self.fig.colorbar(scat, cax=cax,
                                 ticks=cbar_ticks,orientation='horizontal')
        cbar.set_alpha(1)
        cbar.draw_all()
        cbar_tick_labels = [f'<x>-{i}$\sigma$' for i in [5,4,3,2,1]] +['<x>']+ [f'<x>+{i}$\sigma$' for i in [1,2,3,4,5]]
        cbar.ax.set_xticklabels(cbar_tick_labels, horizontalalignment='right', rotation=30)

        cbar.set_label('CR Flux [CR/s/$cm^2$]', fontsize=10)
        # cbar.ax.set_xticklabels(cbar.ax.get_xticklabels(),
        #                         fontweight='medium',fontsize=8)
        if save:
            if not fout:
                fout = 'lat_lon_{}.png'.format(key)

            self.fig.savefig(fout,
                             format='png',bbox_inches='tight',
                             dpi=350, transparent=False)
        plt.show()
        return self.fig

    def plot_hst_loc_cartopy(self, i = 5, df = None, title='',thresh=5,
                     fout='',min_exptime=800, key='start', save=False,
                     orbital_path1=None, orbital_path2=None, projection=ccrs.PlateCarree()):
        fig, ax = plt.subplots(
            nrows=1, 
            ncols=1,
            figsize=(8,7),
            tight_layout=True,
            subplot_kw={'projection': projection}
             )
        crs = projection
        transform = crs._as_mpl_transform(ax)
        df = df[df.integration_time.gt(min_exptime)]
        df.sort_values(by='incident_cr_rate', inplace=True)

        # Plot configuration
        ax.coastlines()
        gl = ax.gridlines(crs=crs, draw_labels=True,
                          linewidth=1, color='k', alpha=0.4, linestyle='--')
        fname ='/ifs/missions/projects/plcosmic/hst_cosmic_rays/APJ_plots/HYP_50M_SR_W.tif'
        ax.imshow(
            plt.imread(fname),
            origin='upper',
            transform=crs,
            extent=[-180, 180, -90, 90]
        )
        gl.xlabels_top = False
        gl.ylabels_left = True
        gl.ylabels_right = False
        gl.xlines = True
        # gl.xlocator = mticker.FixedLocator([-180, -45, 0, 45, 180])
        gl.xformatter = LONGITUDE_FORMATTER
        gl.yformatter = LATITUDE_FORMATTER
        gl.xlocator = MultipleLocator(60)
        gl.ylocator = MultipleLocator(15)
        gl.xlabel_style = {'size': 10, 'color': 'black'}
        gl.xlabel_style = {'color': 'black'}

        date = 2005
        altitude = 565

        # Calculate the B field grid
        # Evenly space grid with 1 degree resolution in both Latitude and Longitude
        lat = np.linspace(-90, 90, 1 * 180 + 1)
        lon = np.linspace(0, 360, 1 * 360 + 1)
        lat_grid, lon_grid = np.meshgrid(lat, lon)
        coordinates = list(zip(lat_grid.ravel(), lon_grid.ravel()))
        B_strength = []
        for coords in coordinates:
            b_field = ipmag.igrf([date, altitude, coords[0], coords[1]])
            B_strength.append(b_field[-1])
        B_strength_grid = np.array(B_strength).reshape(lat_grid.shape)

        # Get the CR rate information
        lat, lon, rate = df['latitude_{}'.format(key)], \
                             df['longitude_{}'.format(key)], \
                             df['incident_cr_rate']
        LOG.info('{} {} {}'.format(len(lat), len(lon), len(rate)))

        # Get average statistics to generate contour
        mean, median, std = sigma_clipped_stats(rate, sigma_lower=3,
                                                sigma_upper=3)
        LOG.info('{} +\- {}'.format(mean, std))
        norm = ImageNormalize(rate,
                              stretch=LinearStretch(),
                              vmin=mean - thresh*std, vmax=mean + thresh*std)
        cbar_below_mean = [mean - (i+1)*std for i in range(thresh)]
        cbar_above_mean = [mean + (i+1)*std for i in range(thresh)]

        cbar_bounds = cbar_below_mean + [mean] + cbar_above_mean
        print(cbar_bounds)
        cbar_bounds.sort()
        sci_cmap = plt.cm.viridis
        custom_norm = colors.BoundaryNorm(boundaries=cbar_bounds,
                                          ncolors=sci_cmap.N)

        
        scat = ax.scatter(
            lon.values, 
            lat.values,
            marker='o',
            s=3.5,
            c=rate, alpha=0.2,
            norm = custom_norm,
            cmap='viridis',
            transform=ccrs.PlateCarree()
            )

        cbar_ticks = cbar_bounds
        cax = fig.add_axes([0.1, 0.2, 0.8, 0.05])
        cbar = fig.colorbar(scat, cax=cax,
                                 ticks=cbar_ticks,orientation='horizontal')
        cbar.set_alpha(1)
        cbar.draw_all()
        cbar_tick_labels = [f'<x>-{i}$\sigma$' for i in [5,4,3,2,1]] +['<x>']+ [f'<x>+{i}$\sigma$' for i in [1,2,3,4,5]]
        cbar.ax.set_xticklabels(cbar_tick_labels, horizontalalignment='right', rotation=30)

        cbar.set_label('CR Flux [CR/s/$cm^2$]', fontsize=10)
      
        cntr = ax.contour(
            lon_grid,
            lat_grid,
            B_strength_grid,
            cmap='plasma', 
            levels=10,
            alpha=1, 
            lw=2, 
            transform=ccrs.PlateCarree()
            )

        h1, l1 = cntr.legend_elements("B_strength_grid")
        l1_custom = [f"{val.split('=')[-1].strip('$').strip()} nT" for val in l1]

        leg1 = Legend(
            ax, h1, l1_custom, loc='upper left', edgecolor='k', 
            fontsize=8,framealpha=0.45,facecolor='tab:gray',
            bbox_to_anchor=(1.05, 1.03), title='Total Magnetic Intensity'
            )
        ax.add_artist(leg1)

        if orbital_path1 is not None:
            ax.scatter(
                orbital_path1.metadata['longitude'][::4][1:],
                orbital_path1.metadata['latitude'][::4][1:],c='k',s=20,label='285 seccond interval'
            )

        if orbital_path2 is not None:
            ax.plot(
                orbital_path2.metadata['longitude'],
                orbital_path2.metadata['latitude'],
                label=f'Orbital Path Over {2000:.0f} seconds',color='k', ls='--', lw=1.25
            )
        plt.show()
        return fig

    def plot_solar_cycle(self, variable=None, ax = None, smoothed=False):
        """ Retrieve solar cycle information

        Parameters
        ----------
        variable
        ax
        smoothed

        Returns
        -------

        """
        noaa = sunpy.timeseries.TimeSeries(sunpy.data.sample.NOAAINDICES_TIMESERIES,
                                           source='NOAAIndices')


        if variable is None and ax is not None:
            noaa.peek(type='sunspot RI', ax=ax)
        elif ax is not None:
            noaa.peek(type=variable, ax=ax)
        return noaa


# if __name__ == '__main__':
#     main()
