#!/usr/bin/env python
"""
A module to facilitate the visualization of data generated by the pipeline.
"""
from collections import Iterable
import logging
from itertools import chain

from astropy.io import fits

from astropy.time import Time
from astropy.stats import sigma_clipped_stats, LombScargle
import astropy.units as u
from astropy.visualization import ImageNormalize, SqrtStretch, LinearStretch, \
    ZScaleInterval, LogStretch, ManualInterval
import costools
import dask.array as da
# from matplotlib import rc
# rc('text', usetex=True)
import matplotlib.pyplot as plt

plt.style.use('ggplot')
from mpl_toolkits.basemap import Basemap
import numpy as np
import pandas as pd
# import pylandau


from scipy.stats import gaussian_kde
import sunpy
import sunpy.timeseries
import sunpy.data.sample

logging.basicConfig(format='%(levelname)-4s '
                           '[%(module)s.%(funcName)s:%(lineno)d]'
                           ' %(message)s',
                    )

LOG = logging.getLogger('visualize')
LOG.setLevel(logging.INFO)




class Visualizer(object):
    """
    A class for visualizing data generated by the pipeline
    """
    def __init__(self):
        pass
        self.image_norms = {
            'log': LogStretch(),
            'linear': LinearStretch(),
            'sqrt' : SqrtStretch(),
        }
        self.map = None

    def mk_fig(self, nrows=1, ncols=1, figsize=(6,6),
               sharex=False,
               sharey=False,
               showgrid=True):
        """ Convenience method for creating a matplotlib figure

        Parameters
        ----------
        nrows : int
            Number of row-subplots to make

        ncols : int
            Number of column-subplots to make

        figsize : tupple of ints
            Size of the figure

        Returns
        -------
        fig : :py:class:`matplotlib.Figure`

        axes : tuple of :py:class:`matplotlib.axes.Axes`
        """
        fig, axes = plt.subplots(nrows=nrows,
                                 ncols=ncols,
                                 figsize=figsize,
                                 sharex=sharex,
                                 sharey=sharey,
                                 gridspec_kw={'wspace': 0.,
                                              'hspace': 0.1})

        if isinstance(axes, Iterable) and not showgrid:
            axes = axes.flatten()
            for ax in axes:
                ax.grid(False)
        elif not showgrid:
            axes.grid(False)
        return fig, axes


    def _perform_SAA_cut(self, df, key):
        saa = [list(t) for t in zip(*costools.saamodel.saaModel(5))]
        saa[0].append(saa[0][0])
        saa[1].append(saa[1][0])
        saa = np.asarray(saa)
        saa_eastern = (39.0, -30.0) # lon/lat
        saa_western = (267.0, -20.0)
        saa_northern = (312.0, 1.0)

        mask = (df['longitude_{}'.format(key)] > saa_eastern[0]) &\
               (df['longitude_{}'.format(key)] < saa_western[0]) &\
               (df['latitude_{}'.format(key)] < saa_northern[1])
        cut = df[mask]

        return cut


    def plot_hist(self, data, bins, label, ax=None, lw=1.75,ls='-',
                  logy=True, logx=False, c='k', range=None, normalize=True):
        """Generate a histogram for a given dataset

        Parameters
        ----------
        data : :py:class:`dask.array`
            THe dask array to use to generate a histogram
        bins: int
            The number of bins to use

        ax : :py:class:`matplotlib.axes.Axes`
            If passed, the histogram will be added to the plot contained by
            this `Axes` instance. Otherwise, one will be created.

        logy : bool
            If True, the y-axis will be plotted on log-scale

        logx : bool
            If True, the logarithm of the `data` input will be taken prior to
            creating the histogram

        Returns
        -------
        fig : :py:class:`matplotlib.figure.Figure`

        ax : :py:class:`matplotlib.axes.Axes`

        hist :
        """
        if logx:
            data = da.log10(data)

        if range is not None:
            h, edges = da.histogram(data, bins=bins,
                                    range=range, density=normalize)
        else:
            h, edges = da.histogram(data, bins=bins, density=normalize)
        hist = h.compute()

        # Create an axis if it doesnt exists
        lw = 1.75
        if ax is None:
            fig, ax = self.mk_fig(nrows=1, ncols=1)
        else:
            fig = None

        if logy:
            # self.ax.step(edges[:-1], h.compute(), color='r')
            ax.semilogy(edges[:-1], hist,
                             label=label,ls=ls,
                             drawstyle='steps-mid', color=c, lw=lw)
        else:
            ax.step(edges[:-1], hist,
                         label=label,ls=ls,
                         where='mid', color=c, lw=lw)
        ax.tick_params(axis='both', which='major',
                       labelsize=10, width=2)
        # ax.legend(loc='best')

        return fig, ax, hist, edges,

    def kde2D_plot(self, parameter1, parameter2, normtype='log',
                   interval=None, xlim=None, ylim=None, gridsize=100):
        """Generate a 2D KDE for the given parameters.

        Parameters
        ----------
        parameter1 : `numpy.array`
            X-axis variable

        parameter2 : `numpy.array`
            Y-axis variable

        normtype : {'log', 'linear', 'sqrt'}
            Normalization type to apply to the data

        interval : tuple
            Limits of the interval to use when computing the image scaling

        xlim : tuple
            X-limits to use for the plot and the KDE grid

        ylim : tuple
            Y-limits to use for the plot and the KDE grid

        gridsize : int
            Step-size for the grid

        Returns
        -------
        fig : :py:class:`matplotlib.figure.Figure`

        ax : :py:class:`matplotlib.axes.Axes`

        surface : numpy.array
            The KDE surface plot
        """

        data = np.vstack([parameter1, parameter2])

        if xlim is None:
            xlim = (np.min(parameter1), np.max(parameter1))

        if ylim is None:
            ylim = (np.min(parameter2), np.max(parameter2))

        # Generate a grid to compute the KDE over
        xgrid = np.linspace(xlim[0], xlim[1], gridsize)
        ygrid = np.linspace(ylim[0], ylim[1], gridsize)


        kde = gaussian_kde(data)
        Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)
        surface = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))

        if isinstance(interval, tuple):
            Interval = ManualInterval(vmin=interval[0], vmax=interval[1])
        else:
            Interval = ZScaleInterval()

        norm = ImageNormalize(surface,
                              stretch=self.image_norms[normtype],
                              interval=Interval)

        fig, ax = self.mk_fig(nrows=1, ncols=1)
        ax.imshow(surface.reshape(Xgrid.shape),
                  norm=norm,
                  cmap='gray',
                  origin='lower',
                  aspect='auto',
                  extent=[xgrid.min(), xgrid.max(), ygrid.min(),ygrid.max()])

        return fig, ax, surface

    def plot_periodogram(self, df, legend_label, exptime_cut=100, ax=None,
                         window='20D', min_periods=10):
        """ Generate a periodogram of the incident CR rate

        Parameters
        ----------
        df : :py:class:`pandas.DataFrame`
            Dataframe containing all of the statistics for the incident CR rate

        legend_label : str
            Label name for the data to display in the plot's legend

        ax : :py:class:`matplotlib.axes.Axes`
            If passed, the histogram will be added to the plot contained by
            this `Axes` instance. Otherwise, one will be created.

         window : str
            String alias for the time period representing the size of the
            moving window. Some common ones are listed below:

            - 'W', one week window
            - '15D', 15 day window
            - 'M', one month window

            A complete list may be found `here <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`_

        min_periods : int
            Minimum number of datapoints that must be in a given window

        Returns
        -------
        frequency : :py:class:`numpy.array` or :py:class:`astropy.Quantity`
            An array of all the frequencies consider in the periodogram

        power : :py:class: `numpy.array`
            An array of the spectral power density associated with frequency

        ax : `matplotlib.axes.Axes`
            The `Axes` for the corresponding plot

        """
        flags = df.integration_time.gt(100)
        df1 = df[flags][['incident_cr_rate','mjd']]
        df1 = df1.rolling(window=window, min_periods=min_periods).mean()
        df1.dropna(inplace=True)
        days = df1['mjd'].values * u.day
        smoothed_rate = df1['incident_cr_rate'].values
        frequency, power = LombScargle(days, smoothed_rate).autopower()

        if ax is None:
            fig, ax = self.mk_fig()
        else:
            ax = ax
        ax.plot(frequency, power, label=legend_label)

        return frequency, power, ax


    def plot_cr_rate_vs_time(self, df, legend_label, ax= None, i=0,min_exptime=200,
                             smooth_type='rolling', window='20D', min_periods=20):
        """Plot the observed cosmic ray rate as a function of time.

        Parameters
        ----------
        df : `pandas.DataFrame`
            DataFrame containing the incident cosmic ray rate information

        legend_label : str
            Label to use for the dataset in the plot legend

        ax : `matplotlib.axes.Axes`
            An instance of a plot to add the current dataset too

        i : int
            Integer used to determine the color of the points used in the
            scatter plot

        smooth_type : {'rolling', 'resample'}
            Type of smoothing to apply to the cosmic ray rate dataset.

            - :py:meth:`pandas.DataFrame.rolling()`
            - :py:meth:`pandas.DataFrame.resample()`

        window : str
            String alias for the time period representing the size of the
            moving window. Some common ones are listed below:

            - 'W', one week window
            - '15D', 15 day window
            - 'M', one month window

            A complete list may be found `here <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`_

        min_periods : int
            Minimum number of datapoints that must be in a given window

        Returns
        -------
        fig : `matplotlib.figure.Figure`

        ax : `matplotlib.axes.Axes`
        """
        # Get the long exposures with reliable statistics
        flags = df.integration_time.gt(min_exptime)
        LOG.info('Total number of observations with exptime > {}: {}'.format(min_exptime,
                                                                             flags.sum()))
        df1 = df[flags][['incident_cr_rate','mjd']]

   

        # Smooth the cosmic ray rate
        if smooth_type == 'rolling':
            LOG.info('Smoothing the data using a '
                     'rolling median over a {} window'.format(window))
            df1 = df1.rolling(window=window, min_periods=min_periods).mean()
        elif smooth_type == 'resample':
            LOG.info('Resampling the data using a rolling median over'
                     'a {} window'.format(window))
            df1 = df1.resample(rule=window).median()


        avg_no_nan = df1.dropna()

        if ax is None:
            fig, ax = self.mk_fig(nrows=1, ncols=1, figsize=(7,4))
        else:
            fig = ax.get_figure()


        # Color cycle to use for repeated use of ax argument
        CB_color_cycle = ['#377eb8', '#ff7f00', '#4daf4a',
                          '#f781bf', '#a65628', '#984ea3',
                          '#999999', '#e41a1c', '#dede00']

        # Make the scatter plot
        ax.scatter([Time(val, format='mjd').to_datetime()
                         for val in avg_no_nan[avg_no_nan.incident_cr_rate.gt(0)]['mjd']],
                        avg_no_nan[avg_no_nan.incident_cr_rate.gt(0)]['incident_cr_rate'],
                        label=legend_label,
                        s=10,
                        color=CB_color_cycle[i])

        # ax.set_xlabel('Date')
        ax.set_ylabel('Cosmic Ray Rate [$CR/s/cm^2$]', fontsize=14)
        # ax.set_title('Smoothed Cosmic Ray Rate')

        return fig, ax


    def draw_map(self, map=None, scale=0.2):

        if map is None:
            pass
        else:
            self.map=map
        # Set the background map up
        self.map.shadedrelief(scale=scale)

        # Draw the meridians
        # lats and longs are returned as a dictionary
        lats = self.map.drawparallels(np.linspace(-90, 90, 13),
                                      labels=[True, False, False, False],
                                      fontsize=8)

        lons = self.map.drawmeridians(np.linspace(-180, 180, 13),
                                      labels=[False, False, False, True],
                                      fontsize=8)

        # keys contain the plt.Line2D instances
        lat_lines = chain(*(tup[1][0] for tup in lats.items()))
        lon_lines = chain(*(tup[1][0] for tup in lons.items()))
        all_lines = chain(lat_lines, lon_lines)
        # cycle through these lines and set the desired style
        for line in all_lines:
             line.set(linestyle='-', alpha=0.3, color='w')


    def plot_hst_loc(self, i = 5, df = None, title='',
                     fout='', key='start', save=False):

        self.fig = plt.figure(figsize=(6, 4))
        # Get the model for the SAA
        self.map = Basemap(projection='cyl')

        self.draw_map()

        # Generate an SAA contour
        saa = [list(t) for t in zip(*costools.saamodel.saaModel(i))]
        # Ensure the polygon representing the SAA is a closed curve by adding
        # the starting points to the end of the list of lat/lon coords
        saa[0].append(saa[0][0])
        saa[1].append(saa[1][0])
        self.map.plot(saa[1], saa[0],
               c='k',
               latlon=True,
               label='SAA contour {}'.format(i))
        # df = self.perform_SAA_cut(df=df, key=key)
        if df is None:
            lat, lon, rate = self.data_df['latitude_{}'.format(key)], \
                             self.data_df['longitude_{}'.format(key)], \
                             self.data_df['incident_cr_rate']
        else:
            # df = df[df['incident_cr_rate'] > 0]
            lat, lon, rate = df['latitude_{}'.format(key)], \
                             df['longitude_{}'.format(key)], \
                             df['incident_cr_rate']
            LOG.info('{} {} {}'.format(len(lat), len(lon), len(rate)))

            # lat1, lon1, rate1 = lat[rate >0], lon[rate >0], rate[rate>0]
            # LOG.info('{} {} {}'.format(len(lat), len(lon), len(rate)))
        # median = np.median(rate)
        # std = np.std(rate)
        mean, median, std = sigma_clipped_stats(rate, sigma_lower=3,
                                                sigma_upper=3)
        LOG.info('{} +\- {}'.format(median, std))
        norm = ImageNormalize(rate,
                              stretch=LinearStretch(),
                              vmin=mean - 4*std, vmax=mean + 4*std)

        geomagnetic_np = pd.read_csv(
            '/Users/nmiles/hst_cosmic_rays/data/geomagnetic_np_locs.txt',
            delimiter=' ')

        geomagnetic_sp = pd.read_csv(
            '/Users/nmiles/hst_cosmic_rays/data/geomagnetic_sp_locs.txt',
            delimiter=' '
        )
        print(geomagnetic_np.head())

        # geomagnetic_np = [360 - 72.69, 80.61]
        # geomagnetic_sp = [107.31, -80.61]
        # for k, c in zip([0, -3], ['#b9773f', '#e227cc']):
        #
        #     self.map.scatter(geomagnetic_np['lon'].values[k],
        #                      geomagnetic_np['lat'].values[k],
        #                      marker='X',c=c,
        #                      label='Geomagnetic'
        #                            ' Poles ({})'.format(
        #                          geomagnetic_np['year'].values[k]),
        #                      s=60, latlon=True)
        #     self.map.scatter(geomagnetic_sp['lon'].values[k],
        #                      geomagnetic_sp['lat'].values[k],
        #                      marker='X',c=c,
        #                      s=60, latlon=True)

        scat = self.map.scatter(lon.values, lat.values,
                         marker='o',
                         s=10,
                         latlon=True,
                         c=rate, alpha=0.8,
                         norm = norm,
                         cmap='Reds')
        ax = plt.gca()
        ax.set_title(title)

        ax1_legend = ax.legend(loc='upper right',
                                ncol=1,
                                labelspacing=0.2,
                                columnspacing=0.5)
        # for i in range(len(ax1_legend.legendHandles)):
        #     ax1_legend.legendHandles[i]._sizes = [30]
        cbar_tick_labels = ['<x>-3$\sigma$', '<x>', '<x>+3$\sigma$']
        cbar_ticks = [mean - 3*std,mean, mean + 3*std]
        cax = self.fig.add_axes([0.1, 0.1, 0.8, 0.05])
        cbar = self.fig.colorbar(scat, cax=cax,
                                 ticks=cbar_ticks,orientation='horizontal')
        cbar.set_alpha(1)
        cbar.draw_all()
        cbar.ax.set_xticklabels(cbar_tick_labels)

        cbar.set_label('CR Rate [CR/s/$cm^2$]', fontsize=10)
        # cbar.ax.set_xticklabels(cbar.ax.get_xticklabels(),
        #                         fontweight='medium',fontsize=8)


        if save:
            if not fout:
                fout = 'lat_lon_{}.png'.format(key)

            self.fig.savefig(fout,
                             format='png',bbox_inches='tight',
                             dpi=250, transparent=False)
        plt.show()


    def plot_solar_cycle(self, variable=None, ax = None, smoothed=False):
        """ Retrieve solar cycle information

        Parameters
        ----------
        variable
        ax
        smoothed

        Returns
        -------

        """
        noaa = sunpy.timeseries.TimeSeries(sunpy.data.sample.NOAAINDICES_TIMESERIES,
                                           source='NOAAIndices')


        if variable is None and ax is not None:
            noaa.peek(type='sunspot RI', ax=ax)
        elif ax is not None:
            noaa.peek(type=variable, ax=ax)
        return noaa


# if __name__ == '__main__':
#     main()
